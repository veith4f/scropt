package lua

import (
	"context"
	"fmt"
	"reflect"
	"runtime"
	"sync"

	v1 "k8s.io/api/core/v1"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

type Registry struct {
	types map[string]reflect.Type
}

var instance *Registry
var once sync.Once

func GetRegistry() *Registry {
	once.Do(initRegistry) // calling the private function inside the public function
	return instance
}

func initRegistry() {
	instance = &Registry{
		types: make(map[string]reflect.Type),
	}

	for _, v := range [...]any{
		context.AfterFunc,
		context.Background,
		context.Cause,
		context.TODO,
		context.WithCancel,
		context.WithCancelCause,
		context.WithDeadline,
		context.WithDeadlineCause,
		context.WithTimeout,
		context.WithTimeoutCause,
		context.WithValue,
		context.WithoutCancel,
		client.IgnoreAlreadyExists,
		client.IgnoreNotFound,
		client.MergeFrom,
		client.MergeFromWithOptions,
		client.New,
		client.NewDryRunClient,
		client.NewNamespacedClient,
		client.NewWithWatch,
		client.ObjectKeyFromObject,
		client.RawPatch,
		client.StrategicMergeFrom,
		client.WithFieldOwner,
		client.WithFieldValidation,
		client.WithSubResourceBody,
		&client.CacheOptions{},
		&client.CreateOptions{},
		&client.DeleteAllOfOptions{},
		&client.DeleteOptions{},
		&client.GetOptions{},
		&client.ListOptions{},
		&client.MatchingFieldsSelector{},
		&client.MatchingLabelsSelector{},
		&client.MergeFromOptions{},
		&client.MergeFromWithOptimisticLock{},
		&client.ObjectKey{},
		&client.Options{},
		&client.PatchOptions{},
		&client.Preconditions{},
		&client.SubResourceCreateOptions{},
		&client.SubResourceGetOptions{},
		&client.SubResourcePatchOptions{},
		&client.SubResourceUpdateOptions{},
		&client.UpdateOptions{},
		&v1.AWSElasticBlockStoreVolumeSource{},
		&v1.Affinity{},
		&v1.AppArmorProfile{},
		&v1.AttachedVolume{},
		&v1.AvoidPods{},
		&v1.AzureDiskVolumeSource{},
		&v1.AzureFilePersistentVolumeSource{},
		&v1.AzureFileVolumeSource{},
		&v1.Binding{},
		&v1.CSIPersistentVolumeSource{},
		&v1.CSIVolumeSource{},
		&v1.Capabilities{},
		&v1.CephFSPersistentVolumeSource{},
		&v1.CephFSVolumeSource{},
		&v1.CinderPersistentVolumeSource{},
		&v1.CinderVolumeSource{},
		&v1.ClientIPConfig{},
		&v1.ClusterTrustBundleProjection{},
		&v1.ComponentCondition{},
		&v1.ComponentStatus{},
		&v1.ComponentStatusList{},
		&v1.ConfigMap{},
		&v1.ConfigMapEnvSource{},
		&v1.ConfigMapKeySelector{},
		&v1.ConfigMapList{},
		&v1.ConfigMapNodeConfigSource{},
		&v1.ConfigMapProjection{},
		&v1.ConfigMapVolumeSource{},
		&v1.Container{},
		&v1.ContainerImage{},
		&v1.ContainerPort{},
		&v1.ContainerResizePolicy{},
		&v1.ContainerState{},
		&v1.ContainerStateRunning{},
		&v1.ContainerStateTerminated{},
		&v1.ContainerStateWaiting{},
		&v1.ContainerStatus{},
		&v1.ContainerUser{},
		&v1.DaemonEndpoint{},
		&v1.DownwardAPIProjection{},
		&v1.DownwardAPIVolumeFile{},
		&v1.DownwardAPIVolumeSource{},
		&v1.EmptyDirVolumeSource{},
		&v1.EndpointAddress{},
		&v1.EndpointPort{},
		&v1.EndpointSubset{},
		&v1.Endpoints{},
		&v1.EndpointsList{},
		&v1.EnvFromSource{},
		&v1.EnvVar{},
		&v1.EnvVarSource{},
		&v1.EphemeralContainer{},
		&v1.EphemeralContainerCommon{},
		&v1.EphemeralVolumeSource{},
		&v1.Event{},
		&v1.EventList{},
		&v1.EventSeries{},
		&v1.EventSource{},
		&v1.ExecAction{},
		&v1.FCVolumeSource{},
		&v1.FlexPersistentVolumeSource{},
		&v1.FlexVolumeSource{},
		&v1.FlockerVolumeSource{},
		&v1.GCEPersistentDiskVolumeSource{},
		&v1.GRPCAction{},
		&v1.GitRepoVolumeSource{},
		&v1.GlusterfsPersistentVolumeSource{},
		&v1.GlusterfsVolumeSource{},
		&v1.HTTPGetAction{},
		&v1.HTTPHeader{},
		&v1.HostAlias{},
		&v1.HostIP{},
		&v1.HostPathVolumeSource{},
		&v1.ISCSIPersistentVolumeSource{},
		&v1.ISCSIVolumeSource{},
		&v1.ImageVolumeSource{},
		&v1.KeyToPath{},
		&v1.Lifecycle{},
		&v1.LifecycleHandler{},
		&v1.LimitRange{},
		&v1.LimitRangeItem{},
		&v1.LimitRangeList{},
		&v1.LimitRangeSpec{},
		&v1.LinuxContainerUser{},
		&v1.List{},
		&v1.LoadBalancerIngress{},
		&v1.LoadBalancerStatus{},
		&v1.LocalObjectReference{},
		&v1.LocalVolumeSource{},
		&v1.ModifyVolumeStatus{},
		&v1.NFSVolumeSource{},
		&v1.Namespace{},
		&v1.NamespaceCondition{},
		&v1.NamespaceList{},
		&v1.NamespaceSpec{},
		&v1.NamespaceStatus{},
		&v1.Node{},
		&v1.NodeAddress{},
		&v1.NodeAffinity{},
		&v1.NodeCondition{},
		&v1.NodeConfigSource{},
		&v1.NodeConfigStatus{},
		&v1.NodeDaemonEndpoints{},
		&v1.NodeFeatures{},
		&v1.NodeList{},
		&v1.NodeProxyOptions{},
		&v1.NodeRuntimeHandler{},
		&v1.NodeRuntimeHandlerFeatures{},
		&v1.NodeSelector{},
		&v1.NodeSelectorRequirement{},
		&v1.NodeSelectorTerm{},
		&v1.NodeSpec{},
		&v1.NodeStatus{},
		&v1.NodeSystemInfo{},
		&v1.ObjectFieldSelector{},
		&v1.ObjectReference{},
		&v1.PersistentVolume{},
		&v1.PersistentVolumeClaim{},
		&v1.PersistentVolumeClaimCondition{},
		&v1.PersistentVolumeClaimList{},
		&v1.PersistentVolumeClaimSpec{},
		&v1.PersistentVolumeClaimStatus{},
		&v1.PersistentVolumeClaimTemplate{},
		&v1.PersistentVolumeClaimVolumeSource{},
		&v1.PersistentVolumeList{},
		&v1.PersistentVolumeSource{},
		&v1.PersistentVolumeSpec{},
		&v1.PersistentVolumeStatus{},
		&v1.PhotonPersistentDiskVolumeSource{},
		&v1.Pod{},
		&v1.PodAffinity{},
		&v1.PodAffinityTerm{},
		&v1.PodAntiAffinity{},
		&v1.PodAttachOptions{},
		&v1.PodCondition{},
		&v1.PodDNSConfig{},
		&v1.PodDNSConfigOption{},
		&v1.PodExecOptions{},
		&v1.PodIP{},
		&v1.PodList{},
		&v1.PodLogOptions{},
		&v1.PodOS{},
		&v1.PodPortForwardOptions{},
		&v1.PodProxyOptions{},
		&v1.PodReadinessGate{},
		&v1.PodResourceClaim{},
		&v1.PodResourceClaimStatus{},
		&v1.PodSchedulingGate{},
		&v1.PodSecurityContext{},
		&v1.PodSignature{},
		&v1.PodSpec{},
		&v1.PodStatus{},
		&v1.PodStatusResult{},
		&v1.PodTemplate{},
		&v1.PodTemplateList{},
		&v1.PodTemplateSpec{},
		&v1.PortStatus{},
		&v1.PortworxVolumeSource{},
		&v1.Preconditions{},
		&v1.PreferAvoidPodsEntry{},
		&v1.PreferredSchedulingTerm{},
		&v1.Probe{},
		&v1.ProbeHandler{},
		&v1.ProjectedVolumeSource{},
		&v1.QuobyteVolumeSource{},
		&v1.RBDPersistentVolumeSource{},
		&v1.RBDVolumeSource{},
		&v1.RangeAllocation{},
		&v1.ReplicationController{},
		&v1.ReplicationControllerCondition{},
		&v1.ReplicationControllerList{},
		&v1.ReplicationControllerSpec{},
		&v1.ReplicationControllerStatus{},
		&v1.ResourceClaim{},
		&v1.ResourceFieldSelector{},
		&v1.ResourceHealth{},
		&v1.ResourceQuota{},
		&v1.ResourceQuotaList{},
		&v1.ResourceQuotaSpec{},
		&v1.ResourceQuotaStatus{},
		&v1.ResourceRequirements{},
		&v1.ResourceStatus{},
		&v1.SELinuxOptions{},
		&v1.ScaleIOPersistentVolumeSource{},
		&v1.ScaleIOVolumeSource{},
		&v1.ScopeSelector{},
		&v1.ScopedResourceSelectorRequirement{},
		&v1.SeccompProfile{},
		&v1.Secret{},
		&v1.SecretEnvSource{},
		&v1.SecretKeySelector{},
		&v1.SecretList{},
		&v1.SecretProjection{},
		&v1.SecretReference{},
		&v1.SecretVolumeSource{},
		&v1.SecurityContext{},
		&v1.SerializedReference{},
		&v1.Service{},
		&v1.ServiceAccount{},
		&v1.ServiceAccountList{},
		&v1.ServiceAccountTokenProjection{},
		&v1.ServiceList{},
		&v1.ServicePort{},
		&v1.ServiceProxyOptions{},
		&v1.ServiceSpec{},
		&v1.ServiceStatus{},
		&v1.SessionAffinityConfig{},
		&v1.SleepAction{},
		&v1.StorageOSPersistentVolumeSource{},
		&v1.StorageOSVolumeSource{},
		&v1.Sysctl{},
		&v1.TCPSocketAction{},
		&v1.Taint{},
		&v1.Toleration{},
		&v1.TopologySelectorLabelRequirement{},
		&v1.TopologySelectorTerm{},
		&v1.TopologySpreadConstraint{},
		&v1.TypedLocalObjectReference{},
		&v1.TypedObjectReference{},
		&v1.Volume{},
		&v1.VolumeDevice{},
		&v1.VolumeMount{},
		&v1.VolumeMountStatus{},
		&v1.VolumeNodeAffinity{},
		&v1.VolumeProjection{},
		&v1.VolumeResourceRequirements{},
		&v1.VolumeSource{},
		&v1.VsphereVirtualDiskVolumeSource{},
		&v1.WeightedPodAffinityTerm{},
		&v1.WindowsSecurityContextOptions{},
	} {
		instance.Register(reflect.ValueOf(v))
	}
}

// Register adds a new type to the registry with the given name
func (r *Registry) Register(val reflect.Value) {
	if val.Kind() == reflect.Ptr {
		val = val.Elem()
	}
	typ := val.Type()
	// structs and functions are handled differently with regard to
	// how their package and name are determined at runtime.
	switch val.Kind() {
	case reflect.Struct:
		r.types[fmt.Sprintf("%s.%s", reflect.Type.PkgPath(typ), reflect.Type.Name(typ))] = typ
	case reflect.Func:
		r.types[runtime.FuncForPC(val.Pointer()).Name()] = typ
	}
}

// Lookup retrieves the type by name from the registry
// It returns the reflect.Value of the registered type and a bool indicating if the type exists
func (r *Registry) Lookup(name string) (reflect.Type, bool) {
	val, ok := r.types[name]
	return val, ok
}
